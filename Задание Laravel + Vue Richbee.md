# Обучающее задание для разработчика Laravel + Vue.js

## Цель задания

Это задание предназначено для изучения и применения практических навыков разработки fullstack приложения на Laravel и Vue.js. Вы будете изучать теоретические концепции и **сразу применять их в реальном проекте** - упрощенной ERP системе для управления производственными заказами.

**Итоговый результат:** Работающий проект, в котором применены все изученные концепции, готовый к защите.

**Технологический стек:**
- Backend: Laravel 11 + PHP 8.3
- Frontend: Vue 3 (Options API) + TailwindCSS
- База данных: PostgreSQL
- Инфраструктура: Docker

---

## Контекст проекта

Вы разрабатываете упрощенную **ERP систему для производственного цеха**.

### Роли в системе:
- **Менеджер** - работает с заказами от контрагентов
- **Диспетчер** - создает производственные задания, следит за их статусами
- **Мастер** - выполняет производственные задания в цехе
- **ОТК (Отдел Технического Контроля)** - проверяет качество выполненных заданий, принимает или отклоняет работу

### Бизнес-процесс:
1. **Менеджер создает заказ** - выбирает контрагента, продукцию, количество, срок выполнения
2. **Диспетчер создает задание в производство** - указывает что производить и в каком количестве, добавляет компоненты (материалы)
3. **Мастер видит задание** - берет в работу, выполняет, отмечает фактическое использование компонентов
4. **Мастер завершает задание** - меняет статус на "на проверке"
5. **ОТК проверяет выполненное задание** - принимает (approved) или отклоняет (rejected)
6. **При принятии ОТК** - задание переходит в статус "completed", заказ автоматически завершается
7. **Менеджер видит заказы в двух таблицах** - актуальные и выполненные

### Основные сущности:
- `User` - пользователи системы `выполнено`
- `Role` - роли пользователей (admin, manager, dispatcher, master, otk) `выполнено`
- `Company` - контрагенты (заказчики) `выполнено`
- `Product` - продукция (целевые изделия и материалы) `выполнено`
- `Order` - заказы от контрагентов (один продукт на заказ) `выполнено`
- `ProductionTask` - задание в производство `выполнено`
- `TaskComponent` - компоненты для задания (материалы в штуках) `выполнено`

---

## Структура обучения

Для каждой темы вы должны:
1. **Изучить теорию** - понять концепцию
2. **Применить в проекте** - реализовать функционал
3. **Подготовить защиту** - объяснить как и почему вы это сделали

---

# BACKEND (Laravel)

## ИНФРАСТРУКТУРА И ОСНОВЫ

---

## 1. Docker и контейнеризация  `выполнено`

### Теория
Изучите работу с Docker и Docker Compose:
- Что такое Docker и контейнеризация
- Dockerfile - создание образов
- docker-compose.yml - оркестрация контейнеров
- Основные команды: docker build, docker run, docker-compose up
- Volumes для персистентности данных
- Networking между контейнерами
- Environment variables в контейнерах

### Применение в проекте
Настройте Docker окружение для проекта:
- Создайте Dockerfile для PHP/Laravel приложения
- Настройте docker-compose.yml с сервисами: app (PHP), nginx, postgres, redis
- Пробросьте volumes для кода и данных БД
- Настройте сеть для связи между контейнерами
- Используйте .env файл для конфигурации контейнеров
- Разверните проект в докере

---

## 2. Конфигурация и переменные окружения `выполнено`

### Теория
Изучите работу с конфигурацией Laravel:
- Файл .env и переменные окружения
- Config файлы в `config/`
- Кэширование конфигурации для production
- Различия между окружениями (local, staging, production)
- Безопасное хранение чувствительных данных

### Применение в проекте
Настройте конфигурацию приложения:
- Использование переменных окружения для БД и других сервисов
- Создание кастомных конфигурационных файлов
- Чтение конфигурации через `config()` helper
- Различные настройки для разных окружений

---

## 3. Миграции и структура БД `выполнено`

### Теория
Изучите миграции Laravel:
- Как создавать миграции
- Типы полей для разных данных
- Как создавать внешние ключи (foreign keys) и настраивать каскадные удаления
- Как создавать индексы для оптимизации запросов
- Как безопасно изменять существующие таблицы

### Применение в проекте `выполнено`
Создайте структуру базы данных для системы:
- Определите необходимые таблицы исходя из бизнес-процесса (users, roles, companies, products, orders, production_tasks, task_components)
- Подберите правильные типы полей для каждой таблицы
- Настройте внешние ключи с каскадными действиями
- Добавьте индексы для оптимизации поиска и фильтрации

---

## 4. ООП принципы

### Теория
Изучите основные принципы ООП:
- **Наследование** - классы могут наследовать свойства и методы от родительских классов
- **Инкапсуляция** - сокрытие внутренней реализации, доступ через публичные методы
- **Полиморфизм** - один интерфейс для разных типов объектов
- **Абстракция** - выделение общих характеристик объектов

### Применение в проекте `выполнено`
Примените принципы ООП в архитектуре сервисов:
- Создайте базовый класс для сервисов с общей логикой
- Реализуйте наследование для специализированных сервисов
- Продемонстрируйте инкапсуляцию и полиморфизм

---

## 5. Связи многие ко многим

### Теория
Изучите связь belongsToMany() в Eloquent:
- Промежуточная таблица для связи
- Методы attach(добавляет одну или несколько связей), detach(удаляет одну, несколько или все связи), sync(синхронизирует связи, оставляет только переданные ID), syncWithoutDetaching(добавляет новые связи, не удаляя существующие)
- Дополнительные поля в pivot таблице задаются через ->withPivot()
- Получение данных pivot через ->withPivot() 'echo $product->pivot->role_id'

### Применение в проекте `выполнено`
Реализуйте систему ролей и пользователей с использованием связи многие-ко-многим:
- Пользователи и роли (admin, manager, dispatcher, master, otk)
- Один пользователь может иметь несколько ролей
- Методы для управления ролями пользователя (назначение, удаление, проверка)
- Seeder с тестовыми пользователями для каждой роли

---

## 6. Работа со связанными таблицами

### Теория
Изучите Eloquent relationships и оптимизацию запросов:
- `hasMany(один ко многим)`, `belongsTo(принадлежность один ко многим)`, `belongsToMany(многи ко многим)`
- Eager Loading: `with()` для предзагрузки связей(можно подгружать как одну, так и несколько связей) (прездагрузка данных и вывод через цикл)
- Проблема N+1 запросов (запрос на получение всех данных + вывод через цикл)
- Методы `withCount('comments' - подсчет количества комментариев и вывод их в comments_count)`, `has('comments' - вывод постов, у которых есть комментарий, 'comments','>=',5)-мин 5 комм`, `whereHas(фильтрация по условиям связи, например комм от определенного id user)`
- `load()` для ленивой загрузки, загружаем только тогда, когда нужно, например грузим комментарии только когда их открывают
- `foreach (User::cursor() as $user) echo $user->name; обрабатываем по одному пользователю и освобождаем память после каждой итерации` и `chunk(1000, function($users)) если пользователей слишком много, обрабатываем частями` для больших выборок

### Применение в проекте `выполнено`
Оптимизируйте загрузку связанных данных:
- Реализуйте получение заказов с контрагентами, продукцией и заданиями без N+1 проблемы
- Добавьте подсчет связанных сущностей
- Примените фильтрацию через связанные таблицы `добавить больше фильтров в OrderService`

---

## 7. Soft Deletes (Мягкое удаление)

### Теория
Изучите мягкое удаление:
- Трейт SoftDeletes 
- Поле deleted_at в миграциях
- Методы restore(востановление после мягкого удаления), forceDelete(удаление игнорируя мягкое удаление)
- Работа с удаленными записями: withTrashed(), onlyTrashed() `можно сортить`
- Каскадное мягкое удаление связанных записей. например мягкое удаление всех тасков компании  

### Применение в проекте `выполнено`
Реализуйте мягкое удаление:
- Добавьте soft deletes для заказов и производственных заданий
- Реализуйте восстановление удаленных записей
- Фильтрация с учетом удаленных данных `но вернись к этому`
- Архивация вместо физического удаления

---

## 8. Dependency Injection и Service Container

### Теория
Изучите внедрение зависимостей и Service Container:
- Что такое Dependency Injection (внедрение зависимостей)
- Constructor Injection - внедрение через конструктор
- Method Injection - внедрение через параметры метода
- Service Container (IoC Container) - контейнер инверсии управления
- Автоматическое разрешение зависимостей (Auto-Resolution)
- Binding и resolving через контейнер
- Type Hinting для автоматического внедрения

### Применение в проекте `выполнено`
Примените Dependency Injection в контроллерах и сервисах:
- Constructor Injection для сервисов в контроллерах
- Method Injection для Request и других зависимостей в методах
- Внедрение собственных сервисов через Service Container
- Понимание как Laravel автоматически разрешает типизированные параметры
С помощью механизма Reflection контейнер анализирует тип (class/interface), указанный в типизированном параметре.
Контейнер пытается создать экземпляр запрошенного класса. Если этому классу нужны свои зависимости, контейнер рекурсивно создает и их тоже.
После успешного создания всех объектов контейнер внедряет готовый экземпляр в метод или конструктор.

---

## БИЗНЕС-ЛОГИКА И API

---

## 9. Сервис-слой

### Теория
Изучите архитектурный паттерн Service Layer:
- Контроллер делегирует бизнес-логику сервису
- Сервис содержит бизнес-логику
- Модель отвечает только за работу с БД
- Преимущества: переиспользование, тестирование, читаемость

### Применение в проекте `выполнено`
Выделите бизнес-логику в сервисы:
- OrderService для управления заказами (создание, получение, завершение)
- ProductionTaskService для управления производственными заданиями (создание, взятие в работу, обновление компонентов, отправка на проверку, принятие/отклонение ОТК)
- Контроллеры должны только делегировать вызовы сервисам

---

## 10. Request классы для валидации

### Теория
Изучите Form Request классы:
- Создание Request классов: `php artisan make:request`
- Метод `rules()` для правил валидации входных данных - возвращает массив правил
- Метод `authorize()` для проверки прав: если возвращает false -> 403forb
- Кастомные сообщения ошибок `messages` для определения стандартных ошибок валидации
- Подготовка данных через `prepareForValidation()` - модификация или дополнение данных перед валидацией

### Применение в проекте `выполнено`
Создайте Request классы для валидации входящих данных:
- Request для создания заказа с валидацией всех полей
- Request для обновления производственного задания
- Request с проверкой прав доступа в методе authorize()
- Кастомные сообщения ошибок на русском языке

---

## 11. DTOs (Data Transfer Objects)

### Теория
Изучите паттерн DTO:
- Назначение DTO для передачи данных между слоями: структурированние данных в одном объекте
- Отличие от моделей Eloquent: DTO(перенос данных, работа только с данными, создается и уничтожается при передаче, проверяет структуру данных). Eloquent(работа с бд, бизнес-логика, много методов, долгоживущий, валидация перед сохранением в бд)
- Типизация и валидация данных public function __construct(public readonly string $login,public readonly string $password,) {}  `<-типизация` если {$this->validate();} + private func validate {if strlen($this->login) < 6 }{throw new InvalidArgumentException}
- Factory паттерн для создания DTO из Request

### Применение в проекте `выполнено`
Реализуйте DTOs для типизации данных:
- DTO для создания/обновления заказов
- DTO для производственных заданий с компонентами
- Factory классы для создания DTO из HTTP Request
- Использование DTO в сервисах вместо массивов

---

## 12. Middleware и авторизация

### Теория
Изучите Middleware и Policy:
- Создание middleware: `php artisan make:middleware`
- Регистрация в `app/Http/Kernel.php`
- Policy классы для авторизации: `php artisan make:policy`
- Gate для простых проверок
- Применение к роутам и контроллерам

### Применение в проекте `выполнено`
Реализуйте систему прав доступа на основе ролей:
- Middleware для проверки ролей пользователя
- Policy для заказов (права на просмотр, создание, редактирование, удаление)
- Policy для производственных заданий (права на создание, взятие в работу, обновление компонентов, завершение, проверку ОТК)

---

## 13. Слоевая архитектура и разделение ответственности

### Теория
Изучите принципы слоевой архитектуры:
- **Controller** - обработка HTTP запросов, валидация входных данных
- **Service** - бизнес-логика приложения
- **Repository** (опционально) - работа с данными
- **Model** - представление данных и связи
- **Job** - фоновые задачи
- **Event/Listener** - обработка событий

### Применение в проекте `выполнено`
Продемонстрируйте правильное разделение ответственности:
- Request классы для валидации
- Policy для проверки прав
- Service для бизнес-логики
- Job для фоновых задач
- Тонкие контроллеры для координации

---

## 14. API Resources для форматирования ответов

### Теория
Изучите Laravel API Resources:
- Создание Resource классов: `php artisan make:resource`
- Трансформация моделей для API ответов
- Resource Collections для коллекций
- Условные атрибуты и связи
- Единообразие структуры JSON ответов

### Применение в проекте `выполнено`
Создайте Resource классы для унификации API ответов:
- Resource для заказов с вложенными контрагентами и продукцией
- Resource для производственных заданий с компонентами
- Collection Resource для списков с пагинацией
- Скрытие чувствительных полей и добавление вычисляемых атрибутов

---

## 15. HTTP статус-коды и REST API

### Теория
Изучите HTTP статус-коды и принципы REST:
- Успешные ответы: 200 (OK), 201 (Created), 204 (No Content)
- Клиентские ошибки: 400 (Bad Request), 401 (Unauthorized), 403 (Forbidden), 404 (Not Found), 422 (Unprocessable Entity)
- Серверные ошибки: 500 (Internal Server Error), 503 (Service Unavailable)
- RESTful именование endpoints
- Идемпотентность методов GET, PUT, DELETE

### Применение в проекте `выполнено`
Правильно используйте HTTP статус-коды в API:
- 201 при создании новых сущностей
- 422 при ошибках валидации с деталями по полям
- 403 при отсутствии прав доступа
- 404 при отсутствии запрашиваемого ресурса
- Понятная структура ошибок в JSON

---

## 16. Фильтрация и пагинация

### Теория
Изучите построение сложных запросов:
- Query Builder: `where()`, `orWhere()`, `whereIn()`
- Условная фильтрация: `when()`
- Пагинация: `paginate()`, `simplePaginate()`
- Сортировка: `orderBy()`, `latest()`, `oldest()`

### Применение в проекте `выполнено`
Реализуйте API endpoints с фильтрацией и пагинацией:
- Список активных и завершенных заказов для менеджера
- Список производственных заданий для диспетчера
- Фильтры по различным параметрам (контрагент, продукция, статус, даты)
- Сортировка и пагинация результатов

---

## ПРОДВИНУТЫЕ ТЕМЫ

---

## 17. Транзакции

### Теория
Изучите работу с транзакциями:
- `DB::transaction(function() {})` - автоматический rollback при исключении
- `DB::beginTransaction()`, `DB::commit()`, `DB::rollBack()` - ручное управление
- Вложенные транзакции и savepoints
- Блокировки: `lockForUpdate()`, `sharedLock()`

### Применение в проекте `выполнено`
Обеспечьте атомарность критичных операций:
- Создание задания с компонентами и привязка к заказу
- Принятие задания ОТК с автозавершением связанного заказа
- Использование блокировок для предотвращения конфликтов

---

## 18. Логирование и отладка

### Теория
Изучите систему логирования Laravel:
- Фасад Log и уровни логирования (debug, info, warning, error, critical)
- Каналы логирования (single, daily, stack)
- Контекстные данные в логах
- Отладка через `dd()`, `dump()`, Laravel Debugbar

### Применение в проекте
Добавьте логирование критичных операций:
- Логирование создания и завершения заказов
- Логирование ошибок при работе с API
- Логирование действий ОТК при проверке заданий
- Структурированные логи с контекстной информацией

---

## 19. Кастомные правила валидации

### Теория
Изучите создание кастомных правил валидации:
- Команда `php artisan make:rule RuleName`
- Метод `passes(string $attribute, $value)` - логика проверки
- Метод `message()` - сообщение об ошибке
- Использование в Request классах

### Применение в проекте `выполнено`
Создайте кастомные правила валидации для бизнес-логики:
- Валидация дедлайнов заказов (должны быть в будущем)
- Валидация переходов между статусами заказов 
- Применение правил в Request классах

---

## 20. Кэширование

### Теория
Изучите кэширование в Laravel:
- `Cache::remember($key, $ttl, $callback)` - кэширование с автозаполнением
- `Cache::get()`, `Cache::put()`, `Cache::forget()` - ручное управление
- Теги кэша: `Cache::tags(['orders', 'reports'])->put()`
- Инвалидация кэша при изменении данных
- Драйверы: Redis, Memcached, Database, File

### Применение в проекте
Реализуйте кэширование для оптимизации производительности:
- Кэширование списка продукции с автоматической инвалидацией
- Кэширование статистики по заказам с использованием тегов
- Кэширование справочных данных (роли, контрагенты)

---

## 21. Jobs (фоновые задачи)

### Теория
Изучите работу с очередями в Laravel:
- Зачем нужны Jobs и очереди
- Создание Job классов: `php artisan make:job JobName`
- Диспатч задач: `JobName::dispatch($data)`
- Методы handle() и failed()
- Свойства $tries, $timeout, $queue
- Цепочки Jobs: `withChain()`
- Delayed dispatch: `dispatch()->delay()`

### Применение в проекте
Вынесите тяжелые операции в фоновые задачи:
- Job для импорта продукции из Excel
- Job для отправки уведомлений менеджерам о заказах
- Job для генерации отчетов по производству
- Настройте повторные попытки и отложенный запуск

---

## 22. Работа с Excel и производственными файлами

### Теория
Изучите работу с файлами Excel:
- Laravel Excel (Maatwebsite) или OpenSpout
- Import классы с методами `model()`, `rules()`, `chunkSize()`
- Обработка по чанкам для больших файлов
- Валидация данных из Excel
- Сбор ошибок валидации

### Применение в проекте
Реализуйте импорт продукции из Excel файла:
- Загрузка и валидация данных из Excel
- Обработка больших файлов по частям
- Сбор и возврат ошибок валидации
- Использование транзакций для целостности данных

---

## 23. Работа с файлами и генерация документов

### Теория
Изучите работу с файлами в Laravel:
- Storage фасад для работы с файловой системой
- Загрузка файлов через Request
- Blade шаблоны для печатных форм
- Управление правами доступа к файлам

### Применение в проекте
Реализуйте функционал работы с документами:
- Генерация печатной формы заказа (Blade шаблон)
- Вывод номера заказа, контрагента, продукции, количества
- Генерация печатной формы производственного задания с компонентами
- Печать доступна только для завершенных заказов/заданий
- Сохранение сгенерированных документов в storage

---

## 24. Работа с запросами к базе данных

### Теория
Изучите различные способы работы с базой данных в Laravel:
- Eloquent ORM - работа через модели
- Query Builder (`DB::table()`) - построитель запросов
- Raw SQL (`DB::select()`, `DB::statement()`) - сырые SQL запросы
- Когда использовать каждый подход
- Оптимизация запросов (`select()`, `chunk()`, `cursor()`)

### Применение в проекте
Продемонстрируйте владение разными способами работы с БД:
- Простые операции через Eloquent модели
- Сложные выборки через Query Builder
- Агрегация и статистика с использованием raw SQL

---

## 25. Тестирование

### Теория
Изучите какие виды тестов существуют в Laravel:

**Типы тестов:**
- **Feature тесты** - тестируют целые сценарии (HTTP запросы, взаимодействие с БД, API)
- **Unit тесты** - тестируют отдельные методы/классы в изоляции

**Что нужно изучить:**
- Как создавать тесты
- Как использовать `DatabaseTransactions` для отката изменений после теста
- Как авторизоваться в тестах через `actingAs()`
- Основные assertions: `assertStatus()`, `assertJson()`, `assertDatabaseHas()`, `assertEquals()`
- Как создавать тестовые данные через фабрики

### Применение в проекте
Напишите несколько тестов для демонстрации понимания:
- Feature тесты для API endpoints (создание заказа, получение списка)
- Unit тесты для методов сервисов

---

# SSR И SPA

---

## 26. SSR и SPA архитектуры

### Теория
Изучите различия между SSR и SPA:
- **SSR (Server-Side Rendering)** - HTML генерируется на сервере, отправляется готовым в браузер
- **SPA (Single Page Application)** - страница загружается один раз, дальше работа через API и JS
- **Blade шаблоны** - для SSR страниц (страница логина, публичные страницы)
- **Vue.js** - для SPA интерфейса (основная работа в системе)

### Применение в проекте
Комбинируйте SSR и SPA в одном приложении:
- **SSR через Blade:** страница авторизации (`/login`), публичные страницы
- **SPA через Vue:** основной интерфейс системы после авторизации
- После успешной авторизации - редирект в Vue SPA приложение
- API endpoints для всей работы SPA части
- Разделение роутов: `web.php` для SSR, `api.php` для SPA

---

# FRONTEND (Vue.js)

---

## 27. Vue компоненты и декомпозиция

### Теория
Изучите создание и переиспользование Vue компонентов:
- Создание компонентов (.vue файлы)
- Props для передачи данных от родителя к ребенку
- Events (emit) для передачи данных от ребенка к родителю
- Slots для гибкого содержимого
- Декомпозиция - разбиение больших компонентов на маленькие
- Переиспользование компонентов в разных частях приложения
- Изоляция логики и стилей

### Применение в проекте
Примените декомпозицию и переиспользование компонентов:
- Вынесите повторяющиеся элементы в отдельные компоненты (кнопки, поля ввода, карточки)
- Создайте компонент для отображения заказа (используется в списке и в детальной карточке)
- Создайте компонент для отображения производственного задания
- Создайте переиспользуемый компонент таблицы с сортировкой и пагинацией
- Правильно используйте props и emit для связи компонентов

---

## 28. Реактивность и ссылки на переменные

### Теория
Изучите реактивность во Vue.js:
- Объекты передаются по ссылке в JavaScript
- Изменения в дочернем компоненте влияют на родительский
- Нарушение однонаправленного потока данных
- Правильно: передавать копию или использовать emit
- Глубокое копирование: `JSON.parse(JSON.stringify())`, `structuredClone()`

### Применение в проекте
Реализуйте компонент редактирования с правильной работой с props:
- Компонент формы принимает данные через props
- Создание локальной копии для предотвращения мутации
- Передача изменений родителю через emit
- Обработка сохранения и отмены изменений

---

## 29. Axios и HTTP запросы

### Теория
Изучите работу с Axios для HTTP запросов:
- Установка и настройка axios
- Базовые методы: `axios.get()`, `axios.post()`, `axios.put()`, `axios.delete()`
- Конфигурация базового URL
- Передача заголовков (Authorization, Content-Type)
- Request/Response interceptors
- Обработка async/await и promises
- **try/catch для обработки ошибок:**
  - Оборачивание axios запросов в try/catch блоки
  - Доступ к ошибке через `error.response` (статус, данные, заголовки)
  - Обработка сетевых ошибок (нет соединения) через `error.request`
  - Общие ошибки через `error.message`

### Применение в проекте
Организуйте работу с API через axios:
- Создание axios instance с базовой конфигурацией (baseURL, headers)
- API методы для работы с заказами, производственными заданиями
- Обработка ошибок через try/catch с проверкой error.response, error.request, error.message
- Response interceptor для централизованной обработки ошибок
- Использование async/await в компонентах и store

---

## 30. Работа с ошибками во Vue

### Теория
Изучите обработку ошибок:
- try/catch для async запросов
- axios interceptors для глобальной обработки
- Статус коды: 422 (валидация), 500 (ошибка сервера), 403 (доступ запрещен)
- Отображение ошибок по полям формы
- Toast уведомления для общих ошибок

### Применение в проекте
Организуйте обработку ошибок на фронтенде:
- Обработка ошибок валидации (422) с отображением по полям
- Обработка ошибок доступа (403) и авторизации (401)
- Обработка серверных ошибок (500)
- Глобальный interceptor для централизованной обработки

---

## 31. Библиотеки глобального состояния (Pinia)

### Теория
Изучите управление состоянием с Pinia:
- Создание store: `defineStore()`
- state - данные
- getters - вычисляемые значения
- actions - методы для изменения state
- Использование в компонентах: `useStore()`

### Применение в проекте
Организуйте управление состоянием через Pinia:
- Store для заказов (активные, завершенные, фильтры)
- Store для производственных заданий (список, текущее задание, операции)
- Правильное использование state, getters и actions
- Интеграция store в компоненты

---

## 32. Vue Router и навигация

### Теория
Изучите Vue Router:
- Определение маршрутов
- Navigation guards: `beforeEach`, `beforeEnter`, `beforeRouteLeave`
- Передача параметров: `params`, `query`
- Программная навигация: `this.$router.push()`
- Предупреждение о несохраненных изменениях

### Применение в проекте
Настройте маршрутизацию с учетом ролей:
- Разделы для каждой роли (заказы, производство, цех, контроль, управление пользователями)
- Navigation guards для проверки доступа по ролям
- Динамическое левое меню в зависимости от ролей пользователя
- Предупреждение о несохраненных изменениях при уходе со страницы

---

# ИТОГОВАЯ ЗАЩИТА ПРОЕКТА

## Демонстрация работы системы

### Бизнес-процесс (продемонстрируйте полный цикл):
1. **Менеджер:** создает заказ от контрагента
2. **Диспетчер:** создает производственное задание с компонентами
3. **Мастер:** берет задание в работу, указывает фактическое использование компонентов, отправляет на проверку
4. **ОТК:** проверяет и принимает задание
5. **Менеджер:** видит завершенный заказ в таблице "Завершенные"

### Функции администратора:
- Управление пользователями (создание, редактирование, удаление)
- Назначение нескольких ролей одному пользователю
- Демонстрация что админ видит все разделы системы

### Система ролей:
Войдите под разными пользователями и покажите как меняется интерфейс (левое меню):
- Менеджер - только раздел "Заказы"
- Диспетчер - только раздел "Производство"
- Мастер - только раздел "Цех"
- ОТК - только раздел "ОТК"
- Админ - все разделы + "Пользователи"
- Пользователь с несколькими ролями - видит соответствующие разделы

---

## Время выполнения

**Рекомендуемое время: 5-7 дней**

Для каждой темы:
- 30-60 минут на изучение теории
- 1-3 часа на реализацию в проекте

---

## Полезные ресурсы

### Официальная документация:
- **Laravel 11 Documentation**: https://laravel.com/docs/11.x
- **Vue.js 3 Guide (Options API)**: https://vuejs.org/guide/
- **PostgreSQL Documentation**: https://www.postgresql.org/docs/
- **Pinia State Management**: https://pinia.vuejs.org/
- **Docker Documentation**: https://docs.docker.com/

### Backend (Laravel):
- **Laravel Eloquent Relationships**: https://laravel.com/docs/11.x/eloquent-relationships
- **Laravel Query Builder**: https://laravel.com/docs/11.x/queries
- **Laravel Validation**: https://laravel.com/docs/11.x/validation
- **Laravel Testing**: https://laravel.com/docs/11.x/testing
- **Laravel Middleware**: https://laravel.com/docs/11.x/middleware
- **Laravel Authorization (Policies)**: https://laravel.com/docs/11.x/authorization
- **Laravel Queues**: https://laravel.com/docs/11.x/queues
- **Laravel Excel**: https://docs.laravel-excel.com/
- **Laravel API Resources**: https://laravel.com/docs/11.x/eloquent-resources
- **Laravel Cache**: https://laravel.com/docs/11.x/cache
- **Laravel Transactions**: https://laravel.com/docs/11.x/database#database-transactions

### Frontend (Vue.js):
- **Vue Router**: https://router.vuejs.org/
- **TailwindCSS**: https://tailwindcss.com/docs
- **Axios**: https://axios-http.com/docs/intro
- **Vue.js Reactivity**: https://vuejs.org/guide/essentials/reactivity-fundamentals.html
- **Vue.js Components**: https://vuejs.org/guide/essentials/component-basics.html

---

**Удачи в выполнении задания!** 🚀
